== Requirement Class "Core"

[[core-overview]]

include::requirements/requirements_class_core.adoc[]

An API that implements this conformance class provides access to the maps and tiles in a link:https://www.w3.org/TR/vocab-dcat/#class-dataset[dataset]. In other words, the API is a link:https://www.w3.org/TR/vocab-dcat/#class-distribution[distribution] of that dataset. A file download, for example, would be another distribution.

The entry point is a `Landing page` (path `/`).

The `Landing page` provides links to

* the `API definition` (path `/api`, link relation `service`),
* the `Conformance declaration` (path `/conformance`, link relation `conformance`), and
* the `Collections` (path `/collections`, link relation `data`).

The `API definition` describes the capabilities of the API that can be used by clients to retrieve resources from the API or by development tools to support the implementation of API servers and clients. Accessing the `API definition` using HTTP GET returns a description of the API.

The `Conformance declaration` states the requirements classes from standards or community specifications, identified by a URI, that the API conforms to. Clients can, but are not required to, use this information. Accessing the `Conformance declaration` using HTTP GET returns the list of URIs of requirements classes implemented by the API.

The data is organized into one or more collections. `Collections` provides information about and access to the collections.

This document does not specify requirements for collections and they can consist on features, coverages or any other resource that can be represented in a map or in a tile. collectionId replaces the concept of layer in WMS and WMTS. Maps or tiles can be generated from one or combination of collections.

This standard does not include any requirements about how features or coverages in the dataset have to be aggregated into collections. A typical approach is to aggregate by collection type but any other approach that fits the dataset or the applications using this distribution may also be used.

Accessing `Collections` using HTTP GET returns a response that contains at least the list of collections. Accessing the items of a collections is out of the scope of this standard and you need to refer to other documents describing OGC APIs for features or coverages. For each `Collection`, a link to metadata about the collection is available (path `/collections/{collectionId}`) with key information about the collection. This information includes:

* A local identifier for the collection that is unique for the dataset;
* A list of coordinate reference systems (CRS) in which geometries may be returned by the API. The first CRS is the default coordinate reference system (in the _Core_, the default is always WGS 84 with axis order longitude/latitude);
* An optional title and description for the collection;
* An optional extent that can be used to provide an indication of the spatial and temporal extent of the collection - typically derived from the data;
* ... TBC

The `Collection` resource is available at path `/collections/{collectionId}`, often with more details than included in the `Collections` response.

=== General Requirements

==== HTTP 1.1

HTTP is the network protocol underlying all Web APIs.

There are no map-specific or tile-specific requirements related to network protocols. API-Common requirements are sufficient to describe this capability for the API-Maps and Tiles standard. The applicable API-Common requirements are as follows:

include::requirements/core/REQ_http-common.adoc[]

[[http_status_codes]]
==== HTTP status codes

This API standard does not impose any restrictions on which features of the HTTP and HTTPS protocols may be used. API clients should be prepared to handle any legal HTTP or HTTPS status code.

The *Status Codes* listed in <<status_codes>> are of particular relevance to implementors of this standard. Status codes 200, 400, and 404 are called out in API requirements. Therefore, support for these status codes is mandatory for all compliant implementations. The remainder of the status codes in <<status_codes>> are not mandatory, but are important for the implementation of a well functioning API. Support for these status codes is strongly encouraged for both client and server implementations.

[#status_codes,reftext='{table-caption} {counter:table-num}']
.Typical HTTP status codes
[cols="15,85",options="header"]
!===
|Status code |Description
|`200` |A successful request.
|`304` |An <<web_caching,entity tag was provided in the request>> and the resource has not been changed since the previous request.
|`400` |The server cannot or will not process the request due to an apparent client error. For example, a query parameter had an incorrect value.
|`401` |The request requires user authentication. The response includes a `WWW-Authenticate` header field containing a challenge applicable to the requested resource.
|`403` |The server understood the request, but is refusing to fulfill it. While status code `401` indicates missing or bad authentication, status code `403` indicates that authentication is not the issue, but the client is not authorised to perform the requested operation on the resource.
|`404` |The requested resource does not exist on the server. For example, a path parameter had an incorrect value.
|`405` |The request method is not supported. For example, a POST request was submitted, but the resource only supports GET requests.
|`406` |The `Accept` header submitted in the request did not support any of the media types supported by the server for the requested resource.
|`500` |An internal error occurred in the server.
!===

More specific guidance is provided for each resource, where applicable.

include::recommendations/core/PER_additional-status-codes.adoc[]

The API Description Document describes the HTTP status codes generated by that API. This should not be an exhaustive list of all possible status codes. It is not reasonable to expect an API designer to control the use of HTTP status codes which are not generated by their software. Therefore, it is recommended that the API Description Document limit itself to describing HTTP status codes relevant to the proper operation of the API application logic. Client implementations should be prepared to receive HTTP status codes in addition to those described in the API Description Document.

[[query_parameters]]
==== Unknown or invalid query parameters

There are no map-specific or tile-specific requirements related to unknown or invalid query parameters. API-Common requirements are sufficient to describe this capability for the API maps and tiles standard. The applicable API-Common requirements are as follows:

include::requirements/core/REQ_query-param-common.adoc[]

===== Unknown query parameters

If an API wants to support vendor specific parameters, these have to be explicitly declared in the API definition.

If OpenAPI is used to represent the API definition, a capability exists to allow additional parameters without explicitly declaring them. That is, parameters that have not been explicitly specified in the API definition for the operation will be ignored.

.OpenAPI schema for additional "free-form" query parameters
[source,YAML]
----
in: query
name: vendorSpecificParameters
schema:
  type: object
  additionalProperties: true
style: form
----

Note that the name of the parameter does not matter as the actual query parameters are the names of the object properties. For example, assume that the value of `vendorSpecificParameters` is this object:

[source,JSON]
----
{
  "my_first_parameter": "some value",
  "my_other_parameter": 42
}
----

In the request URI this would be expressed as `&my_first_parameter=some%20value&my_other_parameter=42`.

===== Invalid query parameters

There is a general rule that applies to all parameters, whether they are specified in this document or in additional parts. A value is invalid if it violates the API definition or any other constraint for that parameter stated in a requirement.

[[encodings]]
==== Encodings

While OGC API map-specific or tile-specific does not specify any mandatory encoding, support for the following encodings is recommended. See <<overview,Clause 6 (Overview)>> for a discussion.

include::recomendations/core/REC_html.adoc[]

include::recomendations/core/REC_geojson.adoc[]

<<_http_1_1,Requirement `/req/core/http`>> implies that the encoding of a server response is determined using content negotiation as specified by the HTTP RFC.

The section <<mediatypes,Media Types>> includes guidance on media types for <<encodings,encodings>> that are specified in this document.

Note that any server that supports multiple encodings will have to support a mechanism to mint encoding-specific URIs for resources in order to express links, for example, to alternate representations of the same resource. This document does not mandate any particular approach how this is supported by the server.

As clients simply need to dereference the URI of the link, the implementation details and the mechanism how the encoding is included in the URI of the link are not important. Developers interested in the approach of a particular implementation, for example, to manipulate ("hack") URIs in the browser address bar, can study the API definition.

[NOTE]
=====================================================================
Two common approaches are:

* an additional path for each encoding of each resource (this can be expressed, for example, using format specific suffixes like ".html");
* an additional query parameter (for example, "accept" or "f") that overrides
the Accept header of the HTTP request.
=====================================================================

[[string_i18n]]
==== String internationalization

If the server supports representing resources in multiple languages, the usual HTTP content negotiation mechanisms apply. The client states its language preferences in the `Accept-Language` header of a request and the server responds with responses that have linguistic text in the language that best matches the requested languages and the capabilities of the server.

include::recomendations/core/REC_string_i18n.adoc[]

For example, if JSON-LD is used as an encoding, the built-in capabilities to link:https://www.w3.org/TR/json-ld/#string-internationalization[annotate a string with its language]
should be used.

The link:https://raw.githubusercontent.com/opengeospatial/oapi_common/master/core/openapi/schemas/link.yaml[link object] based on <<rfc8228,RFC 8288 (Web Linking)>> includes a `hreflang` attribute that can be used to state the language of the referenced resource. This can be used to include links to the same data in, for example, English or French. Just like with <<encodings,multiple encodings>> a server that wants to use language-specific links will have to support a mechanism to mint language-specific URIs for resources in order to express links to, for example, the same resource in another language. Again, this document does not mandate any particular approach how such a capability is supported by the server.

==== Coordinate reference systems

As discussed in Chapter 9 of the <<SDWBP,W3C/OGC Spatial Data on the Web Best Practices document>>, how to express and share the location of a map or tile in a consistent way is one of the most fundamental aspects of map and tile data and it is important to be clear about the coordinate reference system that coordinates are in.

For the reasons discussed in the Best Practices, OGC API maps and tiles uses WGS 84 longitude and latitude as the default coordinate reference system.

include::requirements/core/REQ_crs84-common.adoc[]

=== URL Path Requirements

The following sections describe the formats, behavior and requirements governing the URL Paths used by OGC API maps and tiles implementations.

The OGC strives to maintain a consistent look and feel across all of its' API standards. To that end, features which are common across APIs are defined in the OGC API-Common standard. API-Common requirements will be identified wherever applicable.

==== API landing page

he landing page provides links to the API definition, the Conformance statements and the metadata about the feature data in this dataset.

===== Path Template

 /

===== Returns

[[landingPage]]
.API Landing Page
=================
[source,JSON]
"root" : {
    "required" : [ "links", "title", "description" ],
    "type" : "object",
    "properties" : {
        "title" : {"type" : "string"}
        "description" : {"type" : "string"}
        "links" : {
            "type" : "array",
            "example" : [ {
                "href" : "http://data.example.org/",
                "rel" : "self",
                "type" : "application/json",
                "title" : "this document"
            }, {
                "href" : "http://data.example.org/api",
                "rel" : "service",
                "type" : "application/openapi+json;version=3.0",
                "title" : "the API definition"
            }, {
                "href" : "http://data.example.org/conformance",
                "rel" : "conformance",
                "type" : "application/json",
                "title" : "WFS 3.0 conformance classes implemented by this server"
            }, {
                "href" : "http://data.example.org/collections",
                "rel" : "data",
                "type" : "application/json",
                "title" : "Metadata about the feature collections"
            } ],
            "items" : {
                "$ref" : "#/components/schemas/link"
                }
            }
        }
    }

=================

===== Requirements

There are no map-specific or tile-specific requirements for the API Landing Page. The applicable API-Common requirements are as follows:

include::requirements/core/REQ_root-common.adoc[]

==== API definition

Every API is expected to provide a definition that describes the capabilities of the server and which can be used by developers to understand the API, by software clients to connect to the server, or by development tools to support the implementation of servers and clients.

===== Path Template

 /api

===== Returns

The resource returned from this path is an API Definition Document. Currently only OpenAPI 3.0 is supported. Other definition document types may be supported in the future

===== Requirements

There are no map-specific or tile-specific requirements for the API definition. The applicable API-Common are as follows:

include::requirements/core/REQ_api-common.adoc[]

If multiple API definition formats are supported by a server, use content negotiation to select the desired representation.

The idea is that any OGC API Maps and  Tiles implementation can be used by developers that are familiar with the API definition language(s) supported by the server. For example, if an OpenAPI definition is used, it should be possible to create a working client using the OpenAPI definition. The developer may need to learn a little bit about geometry data types, etc., but it should not be required to read this standard to access the data via the API.

==== Declaration of conformance classes

To support "generic" clients that want to access multiple OGC API Maps and Tiles implementations - and not "just" a specific API / server, the API has to declare the requirements classes it implements and conforms to.

===== Path Template

 /conformance

===== Returns

list all requirements classes specified in a standard (e.g., ) that the API conforms to

[[conformance]]
.Conformance Information
=================
[source,JSON]
"req-classes" : {
    "required" : [ "conformsTo" ],
    "type" : "object",
    "properties" : {
        "conformsTo" : {
            "type" : "array",
            "example" : [
                "http://www.opengis.net/spec/oapi-coverages/1.0/req/core",
                "http://www.opengis.net/spec/oapi-coverages/1.0/req/oas30",
                "http://www.opengis.net/spec/oapi-coverages/1.0/req/html",
                "http://www.opengis.net/spec/oapi-coverages/1.0/req/geojson"
                ],
            "items" : {
                "type" : "string"
                }
            }
        }
    }

=================


===== Requirements

There are no map-specific or tile-specific requirements for the API definition. The applicable API-Common are as follows:

include::requirements/core/REQ_conformance-common.adoc[]

==== Collections metadata

Metadata about the collections shared by this API.

===== Path Template:

/collections

===== Returns:

[[content]]
.API Content Information
=================
[source,JSON]
"content" : {
    "required" : [ "collections", "links" ],
    "type" : "object",
    "properties" : {
        "links" : {
            "type" : "array",
            "example" : [ {
                "href" : "http://data.example.org/collections.json",
                "rel" : "self",
                "type" : "application/json",
                "title" : "this document"
                }, {
                "href" : "http://data.example.org/collections.html",
                "rel" : "alternate",
                "type" : "text/html",
                "title" : "this document as HTML"
                }, {
                "href" : "http://schemas.example.org/1.0/foobar.xsd",
                "rel" : "describedBy",
                "type" : "application/xml",
                "title" : "XML schema for Acme Corporation data"
                } ],
            "items" : {
                "$ref" : "#/components/schemas/link"
                }
            },
        "collections" : {
            "type" : "array",
            "items" : {
                "$ref" : "#/components/schemas/collectionInfo"
                }
            }
        }
    }

=================

===== Requirements:

include::requirements/core/REQ_cc-md-common.adoc[]

==== Collection (singular) metadata

Describes the {collectionId} collection

===== Path Template:

/collections/{collectionId}

===== Path Parameters:

[[collectionId]]
.CollectionID Parameter
=================
[source,JSON]
"collectionId" : {
    "name" : "collectionId",
    "in" : "path",
    "description" : "Identifier (name) of a specific collection",
    "required" : true,
    "style" : "simple",
    "explode" : false,
    "schema" : {
        "type" : "string"
        }
    }

=================

===== Returns:

[[collectionInfo]]
.Collection Information
=================
[source,JSON]
"collectionInfo" : {
    "required" : [ "links", "name" ],
    "type" : "object",
    "properties" : {
        "name" : {
            "type" : "string",
            "description" : "identifier of the collection used, for example, in URIs",
            "example" : "buildings"
            },
        "title" : {
            "type" : "string",
            "description" : "human readable title of the collection",
            "example" : "Buildings"
            },
        "description" : {
            "type" : "string",
            "description" : "a description of the features in the collection",
            "example" : "Buildings in the city of Bonn."
            },
        "links" : {
            "type" : "array",
            "example" : [ {
                "href" : "http://data.example.org/collections/buildings/items",
                "rel" : "item",
                "type" : "application/geo+json",
                "title" : "Buildings"
                }, {
                "href" : "http://example.org/concepts/building.html",
                "rel" : "describedBy",
                "type" : "text/html",
                "title" : "Feature catalogue for buildings"
                } ],
            "items" : {
                "$ref" : "#/components/schemas/link"
                }
            },
        "extent" : {
            "$ref" : "#/components/schemas/extent"
            },
        "crs" : {
            "type" : "array",
            "description" : "The coordinate reference systems in which geometries may be retrieved. Coordinate reference systems are identified by a URI. The first coordinate reference system is the coordinate reference system that is used by default. This is always \"http://www.opengis.net/def/crs/OGC/1.3/CRS84\", i.e. WGS84 longitude/latitude.",
        "items" : {
            "type" : "string"
            },
        "default" :
            [ "http://www.opengis.net/def/crs/OGC/1.3/CRS84" ]
            }
        }
    }

=================
